CLASS BASE VIEW 

در Django، متدهای `setup()` و `dispatch()` در کلاس‌های ویو (`View`) بخش مهمی از چرخه‌ی پردازش درخواست هستند. اگر می‌خوای ویوهای مبتنی بر کلاس (CBV) رو بهتر درک کنی، دونستن نقش این دو متد بسیار مفیده.

---

## ✅ 1. متد `setup(self, request, *args, **kwargs)`

### 🔹 نقش:

قبل از اجرای هر متد `get()`, `post()`, `put()` و غیره، Django این متد را صدا می‌زند تا:

* درخواست (`request`) را در ویو تنظیم کند.
* آرگومان‌ها (`args`, `kwargs`) را ست کند.

### 🔹 تعریف پیش‌فرض:

```python
def setup(self, request, *args, **kwargs):
    self.request = request
    self.args = args
    self.kwargs = kwargs
```

### 🔹 معمولاً چرا override می‌کنیم؟

برای تنظیم داده‌هایی که می‌خواهیم در تمام متدهای ویو استفاده کنیم.

### ✅ مثال:

```python
from django.views import View

class MyView(View):
    def setup(self, request, *args, **kwargs):
        super().setup(request, *args, **kwargs)
        self.user = request.user
        self.is_admin = request.user.is_staff

    def get(self, request, *args, **kwargs):
        if self.is_admin:
            return HttpResponse("Welcome admin!")
        return HttpResponse("Access denied.")
```

---

## ✅ 2. متد `dispatch(self, request, *args, **kwargs)`

### 🔹 نقش:

در واقع نقطه‌ی ورودی اصلی ویو است. این متد تصمیم می‌گیرد کدام متد (مثلاً `get()`, `post()`, `put()` و ...) را اجرا کند.

### 🔹 تعریف پیش‌فرض:

```python
def dispatch(self, request, *args, **kwargs):
    # setup first
    self.setup(request, *args, **kwargs)

    # then call appropriate method
    if request.method.lower() == 'get':
        return self.get(request, *args, **kwargs)
    elif request.method.lower() == 'post':
        return self.post(request, *args, **kwargs)
    ...
```

### 🔹 معمولاً چرا override می‌کنیم؟

* برای اعمال **middleware محلی** (مثلاً چک کردن دسترسی، لاگ‌گرفتن، ...)
* برای کدنویسی DRY در تمام درخواست‌ها

### ✅ مثال:

```python
class MyView(View):
    def dispatch(self, request, *args, **kwargs):
        if not request.user.is_authenticated:
            return HttpResponseForbidden("You must be logged in.")
        return super().dispatch(request, *args, **kwargs)

    def get(self, request, *args, **kwargs):
        return HttpResponse("Welcome, authenticated user!")
```

---

## 🧠 تفاوت کلیدی:

| متد        | نقش                                             |
| ---------- | ----------------------------------------------- |
| `setup`    | مقداردهی اولیه (پیش از dispatch)                |
| `dispatch` | انتخاب متد مناسب (`get`, `post`, ...) برای اجرا |

---

## 🧪 جمع‌بندی استفاده‌ها:

| موقعیت                              | `setup()` | `dispatch()` |
| ----------------------------------- | --------- | ------------ |
| ذخیره‌ی user یا object در self      | ✅         | ✅            |
| بررسی permission                    | ❌         | ✅            |
| خواندن یا تغییر request             | ❌         | ✅            |
| شخصی‌سازی رفتار مشترک در تمام متدها | ❌         | ✅            |

---------------------------------------------------------------------------

در پایتون **mixin** یک الگوی طراحی (design pattern) است که بیشتر برای **اضافه‌کردن قابلیت‌های خاص به کلاس‌ها** استفاده می‌شود، بدون اینکه کل ساختار وراثت آن‌ها را تغییر بدهیم.

به زبان ساده:

* **mixin** معمولاً یک کلاس کوچک است که فقط چند متد یا ویژگی خاص اضافه می‌کند.
* خودش به تنهایی معنای کامل یک موجودیت را ندارد (برخلاف یک کلاس معمولی مثل `Car` یا `User`).
* معمولاً با **وراثت چندگانه** (multiple inheritance) ترکیب می‌شود.

---

## ویژگی‌های مهم mixin

1. **نامفهوم به تنهایی**: یک mixin به‌تنهایی کاربرد زیادی ندارد، باید همراه یک کلاس اصلی استفاده شود.
2. **تمرکز روی یک قابلیت خاص**: مثلاً اضافه کردن قابلیت "قابل چاپ بودن" یا "قابل مرتب‌سازی بودن".
3. **استفاده از multiple inheritance**: کلاس شما هم از کلاس اصلی ارث می‌برد و هم از mixin.

---

## مثال ساده

فرض کنید یک سری کلاس داریم که می‌خواهیم به آن‌ها قابلیت JSON تبدیل کردن بدهیم.

```python
import json

class ToJSONMixin:
    def to_json(self):
        return json.dumps(self.__dict__)


class Person(ToJSONMixin):
    def __init__(self, name, age):
        self.name = name
        self.age = age


class Car(ToJSONMixin):
    def __init__(self, brand, year):
        self.brand = brand
        self.year = year


p = Person("Ali", 30)
c = Car("BMW", 2020)

print(p.to_json())  # {"name": "Ali", "age": 30}
print(c.to_json())  # {"brand": "BMW", "year": 2020}
```

اینجا:

* `ToJSONMixin` یک **mixin** است که فقط قابلیت **تبدیل به JSON** اضافه می‌کند.
* `Person` و `Car` هر دو از آن استفاده کردند و بدون تکرار کد، این قابلیت را گرفتند.

---

## چند نکته مهم در طراحی mixin

* اسم کلاس معمولاً با `Mixin` تمام می‌شود (برای وضوح).
* نباید state پیچیده (مثل `__init__` سنگین) داشته باشد.
* فقط قابلیت اضافه کند، نه اینکه رفتار کلی کلاس را تغییر اساسی بدهد.
* ترتیب وراثت مهم است، چون پایتون از **MRO** (Method Resolution Order) استفاده می‌کند.

---------------------------------------------------------------------------
